import{r,R as Q}from"./index.94vBozfC.js";/**
  * react-collapsed v4.1.2
  *
  * Copyright (c) 2019-2023, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */var V=class extends Error{constructor(e){super(`react-collapsed: ${e}`)}},R=(...e)=>(e[0],`${e[1]}`,void 0);function K(e){const t=r.useRef(e);return r.useEffect(()=>{t.current=e}),r.useCallback((...n)=>t.current?.(...n),[])}function _(e,t,n){const[i,a]=r.useState(t),p=r.useRef(typeof e<"u"),m=p.current?e:i,b=K(n),g=r.useCallback(h=>{const E=typeof h=="function"?h(m):h;p.current||a(E),b?.(E)},[b,m]);return r.useEffect(()=>{R(!(p.current&&e==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),R(!(!p.current&&e!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[e]),[m,g]}var Y="(prefers-reduced-motion: reduce)";function j(){const[e,t]=r.useState(!1);return r.useEffect(()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return;const n=window.matchMedia(Y);t(n.matches);const i=a=>{t(a.matches)};if(n.addEventListener)return n.addEventListener("change",i),()=>{n.removeEventListener("change",i)};if(n.addListener)return n.addListener(i),()=>{n.removeListener(i)}},[]),e}var G=Q.useId||(()=>{});function J(){return G()??""}var X=typeof window<"u"?r.useLayoutEffect:r.useEffect,P=!1,Z=0,q=()=>++Z;function O(e){const t=e||(P?q():null),[n,i]=r.useState(t);return X(()=>{n===null&&i(q())},[]),r.useEffect(()=>{P===!1&&(P=!0)},[]),n!=null?String(n):void 0}function ee(e){const t=J(),n=O(e);return typeof e=="string"?e:typeof t=="string"?t:n}function te(e,t){const n=performance.now(),i={};function a(){i.id=requestAnimationFrame(p=>{p-n>t?e():a()})}return a(),i}function F(e){e.id&&cancelAnimationFrame(e.id)}function M(e){return e?.current?e.current.scrollHeight:(R(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function ne(e){if(!e||typeof e=="string")return 0;const t=e/36;return Math.round((4+15*t**.25+t/5)*10)}function re(e,t){if(e!=null)if(typeof e=="function")e(t);else try{e.current=t}catch{throw new V(`Cannot assign value "${t}" to ref "${e}"`)}}function H(...e){return e.every(t=>t==null)?null:t=>{e.forEach(n=>{re(n,t)})}}function oe(e){let t=n=>{};t=n=>{if(!n?.current)return;const{paddingTop:i,paddingBottom:a}=window.getComputedStyle(n.current);R(!(i&&i!=="0px"||a&&a!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)},r.useEffect(()=>{t(e)},[e])}var ie=typeof window>"u"?r.useEffect:r.useLayoutEffect;function ae({duration:e,easing:t="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:n=()=>{},isExpanded:i,defaultExpanded:a=!1,hasDisabledAnimation:p,id:m,...b}={}){const g=K(n),h=ee(m?`${m}`:void 0),[c,E]=_(i,a),S=r.useRef(c),[B,T]=r.useState(!1),D=j(),A=p??D,y=r.useRef(),v=r.useRef(),u=r.useRef(null),[$,U]=r.useState(null);oe(u);const x=`${b.collapsedHeight||0}px`;function w(d){if(!u.current)return;const s=u.current;for(const l in d){const f=d[l];f?s.style[l]=f:s.style.removeProperty(l)}}return ie(()=>{if(!u.current||c===S.current)return;S.current=c;function s(o){return A?0:e??ne(o)}const l=o=>`height ${s(o)}ms ${t}`,f=o=>{function C(){c?(w({height:"",overflow:"",transition:"",display:""}),g("expandEnd")):(w({transition:""}),g("collapseEnd")),T(!1)}v.current&&F(v.current),v.current=te(C,o)};return T(!0),c?y.current=requestAnimationFrame(()=>{g("expandStart"),w({display:"block",overflow:"hidden",height:x}),y.current=requestAnimationFrame(()=>{g("expanding");const o=M(u);f(s(o)),u.current&&(u.current.style.transition=l(o),u.current.style.height=`${o}px`)})}):y.current=requestAnimationFrame(()=>{g("collapseStart");const o=M(u);f(s(o)),w({transition:l(o),height:`${o}px`}),y.current=requestAnimationFrame(()=>{g("collapsing"),w({height:x,overflow:"hidden"})})}),()=>{y.current&&cancelAnimationFrame(y.current),v.current&&F(v.current)}},[c,x,A,e,t,g]),{isExpanded:c,setExpanded:E,getToggleProps(d){const{disabled:s,onClick:l,refKey:f,...o}={refKey:"ref",onClick(){},disabled:!1,...d},C=$?$.tagName==="BUTTON":void 0,W=d?.[f||"ref"],I={id:`react-collapsed-toggle-${h}`,"aria-controls":`react-collapsed-panel-${h}`,"aria-expanded":c,onClick(z){s||(l?.(z),E(N=>!N))},[f||"ref"]:H(W,U)},k={type:"button",disabled:s?!0:void 0},L={"aria-disabled":s?!0:void 0,role:"button",tabIndex:s?-1:0};return C===!1?{...I,...L,...o}:C===!0?{...I,...k,...o}:{...I,...k,...L,...o}},getCollapseProps(d){const{style:s,refKey:l}={refKey:"ref",style:{},...d},f=d?.[l||"ref"];return{id:`react-collapsed-panel-${h}`,"aria-hidden":!c,"aria-labelledby":`react-collapsed-toggle-${h}`,role:"region",...d,[l||"ref"]:H(u,f),style:{boxSizing:"border-box",...!B&&!c?{display:x==="0px"?"none":"block",height:x,overflow:"hidden"}:{},...s}}}}}export{ae as u};
